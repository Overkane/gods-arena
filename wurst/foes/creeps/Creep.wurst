package Creep
import GameConstants
import PhysicsEntity
import CurrentArena

interface AllCreepsDead
  abstract function execute()

public AllCreepsDead onAllCreepsDead

public constant activeCreeps = new LinkedList<Creep>

public function getPathingNormal(vec2 pos) returns vec2
  let numberOfTests = 8
  let radius = 64.
  vec2 addedVecs = vec2(0, 0)
  for int i = 1 to numberOfTests
    let direction = vec2(0,0).polarOffset((i * 2 * bj_PI/numberOfTests).asAngleRadians(), radius)
    let testPoint = pos + direction
    if testPoint.isTerrainWalkable()
      addedVecs += direction
  return addedVecs.setLength(1.) * (-1.)

public function getBounceVec(vec3 vel3, vec2 nor2) returns vec3
  let nor3 = nor2.toVec3()
  let pv3 = vel3.project(nor3)
  vec2 pv2 = pv3.toVec2()
  pv2 *= (-1.25)
  return vel3 + pv2

public class Creep extends UnitEntity
  use PhysicsModule
  
  construct(int typId, vec3 pos, angle ang)
    super(createUnit(ENEMY_PLAYER, typId, pos.toVec2(), ang))
    actor.setAnimation("birth")
    activeCreeps.add(this)

    EventListener.add(actor, EVENT_PLAYER_UNIT_DEATH, () -> begin
      activeCreeps.remove(this)
      if activeCreeps.isEmpty()
        onAllCreepsDead.execute()
    end)
    
  override function update()
    physicsUpdate(this)
    super.update()

  override function onEscapeGround()
    actor.setPropWindow(0 .fromDeg())

  override function onGroundHit()
    scaleVel(0.75)
    actor.setPropWindow(actor.getDefaultPropWindow())

  override function setXY(vec3 tpos)
    pos = tpos
    if tpos.x > currentArenaRect.getMaxX() or tpos.x < currentArenaRect.getMinX()
      vel = vec3(-vel.x, vel.y, vel.z)
      pos += vel
    else if tpos.y > currentArenaRect.getMaxY() or tpos.y < currentArenaRect.getMinY()
      vel = vec3(vel.x, -vel.y, vel.z)
      pos += vel
      
    actor.setXYZReal(pos)
