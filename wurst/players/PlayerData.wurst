package PlayerData
import GameConstants
import Hero
import Players
import initlater Backpack
import initlater HonorShop
import HashMap
import Entity
import initlater WaveRewards
import SoundUtils
import GeneralFunctions

constant HONOR_POINT_ACQUIRED = new SoundDefinition(Sounds.hint)

// Arena points conversion ratio to honor points
public constant ARENA_POINTS_THRESHOLD = 500

public constant pData = new IterableMap<player, PlayerData>
public constant pDataFromHeroType = new IterableMap<int, PlayerData>

public function player.getData() returns PlayerData
  return pData.get(this)

public tuple maybe_hero(bool have, Hero hero)

public interface MaybeHeroIfPresent
  function if_present(Hero h)

public function maybe_hero.ifPresent(MaybeHeroIfPresent ifPresent)
  if not this.have
    return
  ifPresent.if_present(this.hero)

public function maybeHeroFromHeroType(int type_id) returns maybe_hero
  if pDataFromHeroType.has(type_id)
    return pDataFromHeroType.get(type_id).getHero()
  return maybe_hero(false, null)

public class PlayerData
  private player p
  private maybe_hero maybeHero
  // Game statistic
  private var kills = 0
  private var deaths = 0
  private var physDamage = 0
  private var spellDamage = 0
  private var damageTaken = 0
  private var overallPhysDamage = 0
  private var overallSpellDamage = 0
  private var overallDamageTaken = 0
  private var arenaPoints = 0
  private var arenaPointsForConvertation = 0

  construct (player p)
    this.p = p
    this.maybeHero = maybe_hero(false, null)
    pData.put(p, this)

  function setHero(Hero h)
    this.maybeHero = maybe_hero(true, h)
    pDataFromHeroType.put(h.actor.getTypeId(), this)

  function getHero() returns maybe_hero
    return this.maybeHero

  function addKill()
    kills++

  function getKills() returns int
    return kills

  function addDeath()
    deaths++

  function getDeaths() returns int
    return deaths

  function addPhysDamage(int value)
    physDamage += value
    overallPhysDamage += value

  function getPhysDamage() returns int
    return physDamage

  function getOverallPhysDamage() returns int
    return overallPhysDamage

  function clearPhysDamage()
    physDamage = 0

  function addSpellDamage(int value)
    spellDamage += value
    overallSpellDamage += value

  function getSpellDamage() returns int
    return spellDamage

  function getOverallSpellDamage() returns int
    return overallSpellDamage

  function clearSpellDamage()
    spellDamage = 0

  function addDamageTaken(int value)
    damageTaken += value
    overallDamageTaken += value

  function getDamageTaken() returns int
    return damageTaken

  function getOverallDamageTaken() returns int
    return overallDamageTaken

  function clearDamageTaken()
    damageTaken = 0

  function addArenaPoints(int value)
    arenaPoints += value
    arenaPointsForConvertation += value

    if arenaPointsForConvertation >= ARENA_POINTS_THRESHOLD
      let honorPoints = (arenaPointsForConvertation / ARENA_POINTS_THRESHOLD).floor()
      p
      ..addLumber(honorPoints)
      ..print("You got 1 honor point. You can spend it in " + ("Honor Shop").color(COLOR_GOLD_STR) + " (F3)", 10)

      arenaPointsForConvertation = arenaPointsForConvertation - honorPoints * ARENA_POINTS_THRESHOLD

      HONOR_POINT_ACQUIRED.play()
      
  function getArenaPoints() returns int
    return arenaPoints

  ondestroy
    pData.remove(p)
    this.maybeHero.ifPresent(h -> destroy h)

public function initPlayers()
  let humanPlayers = ALL_PLAYERS.filter((player p) -> p != ENEMY_PLAYER)
  humanPlayers.forEach() p ->
    new PlayerData(p)

  onPlayerLeave() p ->
    destroy p.getData()
    for backpack in backpackUnits
      if backpack.getOwner() == p
        destroy backpack.getEntity()
        break

    for honorShop in honorShopUnits
      if honorShop.getOwner() == p
        destroy honorShop.getEntity()
        break

    // p.clearPlayerCustomStatUI() TODO produces crash on player leave, cuz can't destroy frame on player leave or something like that

    printTimed(p.getNameColored() + " has left the game", 15.)
    printTimed("All players get " + expCompensationOnPlayerLeave.toString().color(COLOR_GOLD_STR) + " experience and "
      + goldCompensationOnPlayerLeave.toString().color(COLOR_GOLD_STR) + " gold as compensation.", 15.)
    
    pData.forEach() (player p, PlayerData playerData) ->
      p.addGold(goldCompensationOnPlayerLeave)
      playerData.getHero().ifPresent() (Hero h) ->
        h.addXp(expCompensationOnPlayerLeave, false)
    
    let remainingPlayers = ALL_PLAYERS.filter((player p) -> p != ENEMY_PLAYER)
    setHandicap(remainingPlayers.size())

