package DamageSystem
import StandardTextTags
import public DamageEvent
import public CustomStatSystem
import PlayerData
import GameConstants
import CustomHeal
import ObjEditingNatives

public class DamageTypeTooltips
  static constant StringLevelClosure physical = lvl -> "Physical".color(colorA(223, 59, 33, 255))
  static constant StringLevelClosure magical = lvl -> "Magical".color(colorA(91, 147, 209, 255))
  static constant StringLevelClosure pure = lvl -> "Pure".color(colorA(194, 156, 74, 255))

public enum DamageEvents
  START // First listener, where can be set stats for next listeners
  EVASION // Evasion related
  RELATIVE // Damage affected by multiplication and division
  ABSOLUTE // Damage affected by addition and subtraction
  CRIT // Damage affected by crits
  SHIELD // Damage reduced by shield
  FINAL // Final damage

// Damage ignores magic immunity, but reduced by armor
public function unit.dealPhysicalDamage(widget target, real amount)
  DamageEvent.setNextDamageFromCode()
  this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)

// Damage ignores armor, but reduced by magic resistance
public function unit.dealMagicalDamage(widget target, real amount)
  DamageEvent.setNextDamageFromCode()
  this.damageTarget(target, amount, false, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_MAGIC, WEAPON_TYPE_WHOKNOWS)

// Damage ignores magic immunity, magic resistance and armor reduction
public function unit.dealPureDamage(widget target, real amount)
  DamageEvent.setNextDamageFromCode()
  this.damageTarget(target, amount)

public function isPhysicalDamage() returns bool
  return DamageEvent.getAttackType() == ATTACK_TYPE_CHAOS and DamageEvent.getDamageType() == DAMAGE_TYPE_NORMAL
    and DamageEvent.getType() == DamageType.CODE or DamageEvent.getType() == DamageType.ATTACK

// Condition "DamageEvent.getType() == DamageType.SPELL" is here until all spells will be customly made.
public function isMagicalDamage() returns bool
  return DamageEvent.getAttackType() == ATTACK_TYPE_CHAOS and DamageEvent.getDamageType() == DAMAGE_TYPE_MAGIC
    and DamageEvent.getType() == DamageType.CODE or DamageEvent.getType() == DamageType.SPELL

public function isPureDamage() returns bool
  return DamageEvent.getAttackType() == ATTACK_TYPE_CHAOS and DamageEvent.getDamageType() == DAMAGE_TYPE_UNIVERSAL
    and DamageEvent.getType() == DamageType.CODE

init
  DamageEvent.addUnreducedListener(DamageEvents.EVASION castTo int) ->
    let damageType = DamageEvent.getType()
    let tunit = DamageEvent.getTarget()

    if damageType == DamageType.ATTACK
      let tUnitEvasion = tunit.getStat(CustomUnitStats.EVASION)

      if tUnitEvasion > GetRandomReal(0, 1)
        DamageEvent.abortCurrent()
        createMissTextTag(tunit)

  DamageEvent.addUnreducedListener(DamageEvents.RELATIVE castTo int) ->
    let sunit = DamageEvent.getSource()
    var damage = DamageEvent.getAmount()

    if isPhysicalDamage()
      damage = DamageEvent.getAmount() + DamageEvent.getAmount() * sunit.getStat(CustomUnitStats.ATTACK_POWER)

    else if isMagicalDamage()
      let tunit = DamageEvent.getTarget() 
      damage = (1 - tunit.getStat(CustomUnitStats.MAGIC_RESISTANCE)) * (DamageEvent.getAmount() + DamageEvent.getAmount() * sunit.getStat(CustomUnitStats.SPELL_POWER))
      
    DamageEvent.setAmount(damage)

  DamageEvent.addUnreducedListener(DamageEvents.ABSOLUTE castTo int) ->
    let damageType = DamageEvent.getType()
    let sunit = DamageEvent.getSource()
    var damage = DamageEvent.getAmount()

    // Bonus attack damage applies only for default attacks.
    if damageType == DamageType.ATTACK
      damage = DamageEvent.getAmount() + sunit.getStat(CustomUnitStats.BONUS_ATTACK_DAMAGE)

    else if isMagicalDamage()
      damage = DamageEvent.getAmount() + sunit.getStat(CustomUnitStats.BONUS_SPELL_DAMAGE)
      
    DamageEvent.setAmount(damage)

  DamageEvent.addUnreducedListener(DamageEvents.CRIT castTo int) ->
    let damageType = DamageEvent.getType()
    let sunit = DamageEvent.getSource()
    var damage = DamageEvent.getAmount()

    if damageType == DamageType.ATTACK
      let attackCritChance = sunit.getStat(CustomUnitStats.ATTACK_CRIT_CHANCE)
      
      if attackCritChance > GetRandomReal(0, 1)
        damage = DamageEvent.getAmount() + DamageEvent.getAmount() * sunit.getStat(CustomUnitStats.ATTACK_CRIT_POWER)

    else if isMagicalDamage()
      let spellCritChance = sunit.getStat(CustomUnitStats.SPELL_CRIT_CHANCE)
      
      if spellCritChance > GetRandomReal(0, 1)
        damage = DamageEvent.getAmount() + DamageEvent.getAmount() * sunit.getStat(CustomUnitStats.SPELL_CRIT_POWER)
    
    DamageEvent.setAmount(damage)

  DamageEvent.addUnreducedListener(DamageEvents.FINAL castTo int) ->
    let sunit = DamageEvent.getSource()
    var damage = DamageEvent.getAmount()

    // Applying magic resistance after all calculations.
    // Physical damage is reduced by default war3 mechanism.
    if isMagicalDamage()
      damage = DamageEvent.getAmount() * (1 - sunit.getStat(CustomUnitStats.MAGIC_RESISTANCE))
      
    DamageEvent.setAmount(damage)

// Lifesteal is calculated after all damage calculations
  DamageEvent.addListener() ->
    let damageType = DamageEvent.getType()
    let sunit = DamageEvent.getSource()

    if damageType == DamageType.ATTACK
      let lifestealAmount = sunit.getStat(CustomUnitStats.LIFESTEAL)
      
      if lifestealAmount != 0
        let healValue = DamageEvent.getAmount() * lifestealAmount
        sunit.healTarget(sunit, healValue, false)

    else if isMagicalDamage()
      var attacker = sunit
      
      if sunit.hasAbility(LOCUST_ID) and sunit.getOwner().isHuman()
        attacker = pData.get(sunit.getOwner()).getHero().hero.actor

      let lifestealAmount = attacker.getStat(CustomUnitStats.SPELL_LIFESTEAL)
      
      if lifestealAmount != 0
        let healValue = DamageEvent.getAmount() * lifestealAmount
        attacker.healTarget(attacker, healValue, false)
    